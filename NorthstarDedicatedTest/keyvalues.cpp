#include "pch.h"
#include "keyvalues.h"
#include "modmanager.h"
#include "filesystem.h"

#include <fstream>

void ModManager::TryBuildKeyValues(const char* filename)
{
	spdlog::info("Building KeyValues for file {}", filename);

	std::string normalisedPath = fs::path(filename).lexically_normal().string();
	fs::path compiledPath = COMPILED_ASSETS_PATH / filename;
	fs::path compiledDir = compiledPath.parent_path();
	fs::create_directories(compiledDir);

	fs::path kvPath(filename);
	std::string ogFilePath = "mod_original_";
	ogFilePath += kvPath.filename().string();

	std::string newKvs = "// AUTOGENERATED: MOD PATCH KV\n";

	int patchNum = 0;

	// copy over patch kv files, and add #includes to new file, last mods' patches should be applied first
	for (int i = m_loadedMods.size() - 1; i > -1; i--)
	{
		size_t fileHash = std::hash<std::string>{}(normalisedPath);
		for (int j = 0; j < m_loadedMods[i]->KeyValuesHash.size(); j++)
		{
			if (fileHash == m_loadedMods[i]->KeyValuesHash[j])
			{
				// should result in smth along the lines of #include "mod_patch_5_mp_weapon_car.txt"

				std::string patchFilePath = "mod_patch_";
				patchFilePath += std::to_string(patchNum++);
				patchFilePath += "_";
				patchFilePath += kvPath.filename().string();

				newKvs += "#base \"";
				newKvs += patchFilePath;
				newKvs += "\"\n";

				fs::remove(compiledDir / patchFilePath);

				fs::copy_file(m_loadedMods[i]->ModDirectory / "keyvalues" / filename, compiledDir / patchFilePath);
			}
		}
	}

	newKvs += "#base \"";
	newKvs += ogFilePath;
	newKvs += "\"\n";

	// load original file, so we can parse out the name of the root obj (e.g. WeaponData for weapons)
	std::string originalFile = ReadVPKOriginalFile(filename);
	char rootName[64];
	memset(rootName, 0, sizeof(rootName));

	// iterate over all lines that aren't empty, and don't start with #s or //s, first one should be the name of the root obj
	int i = 0;
	while (!(originalFile[i] >= 65 && originalFile[i] <= 122))
	{
		// if we hit a comment or # thing, iterate until end of line
		if (originalFile[i] == '/' || originalFile[i] == '#')
			while (originalFile[i] != '\n')
				i++;
	
		i++;
	}
	
	int j = 0;
	for (int j = 0; originalFile[i] >= 65 && originalFile[i] <= 122; j++)
		rootName[j] = originalFile[i++];
	
	// empty kv, all the other stuff gets #base'd or #include'd
	newKvs += rootName;
	newKvs += "\n{\n}\n";

	std::ofstream originalFileWriteStream(compiledDir / ogFilePath);
	originalFileWriteStream << originalFile;
	originalFileWriteStream.close();

	std::ofstream writeStream(compiledPath);
	writeStream << newKvs;
	writeStream.close();

	ModOverrideFile* overrideFile = new ModOverrideFile;
	overrideFile->owningMod = nullptr;
	overrideFile->path = normalisedPath;

	if (m_modFiles.find(normalisedPath) == m_modFiles.end())
		m_modFiles.insert(std::make_pair(normalisedPath, overrideFile));
	else
		m_modFiles[normalisedPath] = overrideFile;
}